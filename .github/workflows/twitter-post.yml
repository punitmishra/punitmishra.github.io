name: Post to Twitter/X

on:
  push:
    branches: [main]
    paths:
      - 'public/content/blog/*.md'
      - 'public/content/blog/index.json'

  workflow_dispatch:
    inputs:
      article_slug:
        description: 'Article slug to post (e.g., shield-ai-dns-security)'
        required: true
        type: string
      dry_run:
        description: 'Dry run (preview only, no actual post)'
        required: false
        type: boolean
        default: false

jobs:
  post-tweet:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Detect new/updated articles
        id: detect
        if: github.event_name == 'push'
        run: |
          CHANGED=$(git diff --name-only HEAD~1 HEAD -- 'public/content/blog/*.md' | head -1)
          if [ -n "$CHANGED" ]; then
            SLUG=$(basename "$CHANGED" .md)
            echo "slug=$SLUG" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
            echo "Detected article: $SLUG"
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "No new articles detected"
          fi

      - name: Set article slug
        id: article
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "slug=${{ github.event.inputs.article_slug }}" >> $GITHUB_OUTPUT
            echo "dry_run=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
          else
            echo "slug=${{ steps.detect.outputs.slug }}" >> $GITHUB_OUTPUT
            echo "dry_run=false" >> $GITHUB_OUTPUT
          fi

      - name: Read article metadata
        id: metadata
        if: steps.detect.outputs.found == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          SLUG="${{ steps.article.outputs.slug }}"
          ARTICLE_PATH="public/content/blog/${SLUG}.md"

          if [ ! -f "$ARTICLE_PATH" ]; then
            echo "Article not found: $ARTICLE_PATH"
            exit 1
          fi

          # Extract title - remove 'title:' prefix and quotes
          TITLE=$(grep -m1 '^title:' "$ARTICLE_PATH" | sed 's/^title: *//' | sed 's/^"//' | sed 's/"$//')

          # Extract first 3 tags
          TAGS=$(grep -m1 '^tags:' "$ARTICLE_PATH" | sed 's/^tags: *\[//' | sed 's/\]//' | tr -d '"' | cut -d',' -f1-3 | tr ',' ' ')

          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "Title: $TITLE"
          echo "Tags: $TAGS"

      - name: Format tweet
        id: tweet
        if: steps.detect.outputs.found == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          SLUG="${{ steps.article.outputs.slug }}"
          TITLE="${{ steps.metadata.outputs.title }}"
          TAGS="${{ steps.metadata.outputs.tags }}"
          URL="https://punitmishra.github.io/#/blog/${SLUG}"

          # Format hashtags
          HASHTAGS=""
          for tag in $TAGS; do
            clean=$(echo "$tag" | tr -d ' ' | sed 's/[^a-zA-Z0-9]//g')
            if [ -n "$clean" ]; then
              HASHTAGS="$HASHTAGS #$clean"
            fi
          done

          # Build tweet
          cat > tweet.txt << TWEETEOF
          New article: ${TITLE}
          ${HASHTAGS}

          ${URL}
          TWEETEOF

          echo "Tweet preview:"
          cat tweet.txt

      - name: Post to Twitter/X
        if: (steps.detect.outputs.found == 'true' || github.event_name == 'workflow_dispatch') && steps.article.outputs.dry_run != 'true'
        env:
          TWITTER_API_KEY: ${{ secrets.TWITTER_API_KEY }}
          TWITTER_API_SECRET: ${{ secrets.TWITTER_API_SECRET }}
          TWITTER_ACCESS_TOKEN: ${{ secrets.TWITTER_ACCESS_TOKEN }}
          TWITTER_ACCESS_SECRET: ${{ secrets.TWITTER_ACCESS_SECRET }}
        run: |
          if [ -z "$TWITTER_API_KEY" ]; then
            echo "Twitter API keys not configured"
            exit 0
          fi

          # Install twurl for easier Twitter API access
          npm install -g twurl-cli 2>/dev/null || true

          TWEET=$(cat tweet.txt)

          # Use curl with OAuth 1.0a
          TIMESTAMP=$(date +%s)
          NONCE=$(openssl rand -hex 16)

          # For simplicity, use a Node.js script for OAuth
          cat > post-tweet.js << 'JSEOF'
          const crypto = require('crypto');
          const https = require('https');

          const apiKey = process.env.TWITTER_API_KEY;
          const apiSecret = process.env.TWITTER_API_SECRET;
          const accessToken = process.env.TWITTER_ACCESS_TOKEN;
          const accessSecret = process.env.TWITTER_ACCESS_SECRET;
          const tweet = require('fs').readFileSync('tweet.txt', 'utf8').trim();

          function generateOAuthSignature(method, url, params, consumerSecret, tokenSecret) {
            const sortedParams = Object.keys(params).sort().map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`).join('&');
            const signatureBase = `${method}&${encodeURIComponent(url)}&${encodeURIComponent(sortedParams)}`;
            const signingKey = `${encodeURIComponent(consumerSecret)}&${encodeURIComponent(tokenSecret)}`;
            return crypto.createHmac('sha1', signingKey).update(signatureBase).digest('base64');
          }

          const timestamp = Math.floor(Date.now() / 1000).toString();
          const nonce = crypto.randomBytes(16).toString('hex');

          const oauthParams = {
            oauth_consumer_key: apiKey,
            oauth_nonce: nonce,
            oauth_signature_method: 'HMAC-SHA1',
            oauth_timestamp: timestamp,
            oauth_token: accessToken,
            oauth_version: '1.0'
          };

          const url = 'https://api.twitter.com/2/tweets';
          const signature = generateOAuthSignature('POST', url, oauthParams, apiSecret, accessSecret);
          oauthParams.oauth_signature = signature;

          const authHeader = 'OAuth ' + Object.keys(oauthParams).sort().map(k => `${encodeURIComponent(k)}="${encodeURIComponent(oauthParams[k])}"`).join(', ');

          const postData = JSON.stringify({ text: tweet });

          const options = {
            hostname: 'api.twitter.com',
            port: 443,
            path: '/2/tweets',
            method: 'POST',
            headers: {
              'Authorization': authHeader,
              'Content-Type': 'application/json',
              'Content-Length': Buffer.byteLength(postData)
            }
          };

          const req = https.request(options, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
              console.log('Response:', data);
              const json = JSON.parse(data);
              if (json.data && json.data.id) {
                console.log('Tweet posted: https://twitter.com/punitmishra/status/' + json.data.id);
                process.exit(0);
              } else {
                console.error('Failed to post tweet');
                process.exit(1);
              }
            });
          });

          req.on('error', (e) => {
            console.error('Error:', e.message);
            process.exit(1);
          });

          req.write(postData);
          req.end();
          JSEOF

          node post-tweet.js

      - name: Dry run summary
        if: steps.article.outputs.dry_run == 'true'
        run: |
          echo "DRY RUN - Tweet would be:"
          cat tweet.txt
          echo "No actual tweet was posted."
